# 第三章 研究数据与方法
## 3.1 研究范围
本文选取上海市作为研究区域。上海市北界长江，南枕杭州湾，西接江浙两省，东临东海，全市面积 6340.5 平方公里，现辖16个市辖区：黄浦区、徐汇区、长宁区、静安区、普陀区、虹口区、杨浦区、闵行区、宝山区、嘉定区、浦东新、金山区、松江区、青浦区、奉贤区、崇明区。参考第七次全国人口普查主要数据，上海市常住人口为 24870895 人。近几十年来经济飞速发展的同时，上海市逐步形成了多中心、高人口密度及高混杂度的城市格局，这也进一步引起人口拥挤、交通拥堵和环境污染等大城市病。这些城市特征也同时存在于中国大多数大型、超大型城市中，选取作为中国经济中心的上海为研究区域具有一定的典型意及泛化意义。

## 3.2 数据来源与预处理

### 3.2.1 数据来源与数据清洗
本文的研究数据包括骑行轨迹数据与上海市基本地理信息数据，其中骑行轨迹包括由互联网采集整理得到的 2016 年 8 月整月 102361 条上海市某品牌共享单车骑行轨迹数据及 2020 年 8 月整月 12793 条骑行记录，上海市基本地理信息数据包括由 Open  Street  Map 开源地理信息数据网站获取上海市路网矢与兴趣点分布矢量数据及由高德地图开放平台获取的上海市矢量边界数据。

2016 年骑行记录数据较为详细，除了常见的骑行起止时间及起止点位置字段外，还包含了一个以“#”分隔的骑行轨迹点集字段，但是由于网络延迟、设备故障等原因该字段内的轨迹点为乱序排列，需要设计算法以恢复正确的骑行轨迹（具体方法见 3.2.2），并且骑行实际距离也需要根据正确的轨迹数据计算（计算方法见 3.2.4）。2020 年骑行记录并未包含详细的骑行轨迹点集，但提供骑行距离。对于骑行记录数据，按照如下规则清洗：1）去除骑行时长小于1分钟大于 8 小时的骑行记录；2）对于有轨迹点集的数据，去除记录到的轨迹点数量小于 3 个的记录；3）去除存在字段缺失及异常符号的记录；4）去除骑行终点位于上海市之外的记录，该记录超出研究区域。

| 字段 | 说明 | 字段值 |
| -- | -- | -- |
| ID | 编号 | 1 |
| BID | 单车编号 | 79699 | 
| UID | 用户编号 | 759 |
| ST | 开始时间 | 2016/8/1 0:23 |	
| SX | 起点经度 | 121.520 |	
| SY | 起点纬度 | 31.309 |	
| ET | 结束时长 | 2016/8/1 0:32 |	
| DU | 骑行时间 | 9 |	
| EX | 终点经度 | 121.525 |	
| EY | 终点纬度 | 31.316 |		
| WD | 星期 | 星期一 |		
| track | 轨迹点 | 121.520,31.309#... |

> 注：轨迹点并不按照骑行时间排列，存在乱序点及定位异常点，需要算法处理。

上海市基本地理信息数据的预处理使用 QGIS 软件处理，使用 QGIS 软件解析 Open  Street  Map 网站内部格式（ *.OSM ）的矢量数据将其转换为常用的 shapefile 文件格式( *.shp )并使用上海市矢量边界数据裁剪掉区域外的部分。从上海市路网数据集中抽取出五个级别道路（主路、次主路、支路、骑行道路、人行道）共计 46445 条数据。

![](../imgs/c3/路网.jpg)

从上海市兴趣点数据集中抽取出八个类别的兴趣点集（交通设施服务、体育休闲服务、公司企业、商务住宅、科教文化服务、购物服务、风景名胜、餐饮服务）共计 122608 条数据。

| 类名 | 英文名 | 编码 |
| -- | -- | -- |
| 交通设施服务 | Transportation | 0 |
| 体育休闲服务 | Sports and Leisure | 1 |
| 公司企业 | Company | 2 |
| 商务住宅 | Business Residence | 3 |
| 科教文化服务 | Science and Education Culture | 4 |
| 购物服务 | Shopping | 5 |
| 风景名胜 | Scenic Spots | 6 |
| 餐饮服务 | Catering | 7 |

![](../imgs/c3/poi.jpg)

### 3.2.2 轨迹重排序及长度量测
2008年 Gustavo Niemeyer 提出了 GeoHash 地理编码系统[20]，它能将地理位置编码成由字母和数字组成的短字符串。GeoHash 是一种多层级的空间数据结构，通过网格状的划分及 Z 形空间填充曲线 (Z-order curve)方式将空间进行编码。GeoHash 编码精度可以通过增加编码字符长度无限拓展，同时可以通过去除编码末尾的字符来降低精度 (空间精度随之降低)。

由于其编码结构具有层级性，GeoHash 保证了两个共享前缀越长的编码，其代表的地理位置越接近；由于其采用具有空间突变特性的 Z 形空间填充曲线，GeoHash 无法保证距离很近的两个地理位置一定具有相同的编码前缀，且具有多位共享前缀的编码实际距离也有可能很远（多发生与边界处）。这种前缀匹配程度并不完全等同于地理距离的接近程度的现象被称为距离失真。

计算 GeoHash 首先需要将经纬度坐标分别转换为二进制表示。然后按照“经度值占偶数位，纬度值占奇数位”的规则将经纬度交织为一个二进制串，最后使用 Base32 编码转换为字符串。GeoHash 算法的计算过程可以概括为以下公式：

$$GeoHash(lon, lat) = Base32(Interleave(Binary(lon), Binary(lat)))$$

其中，`Interleave` 函数表示经纬度二进制值的交织操作，`Base32` 函数表示二进制值转换为 Base32 编码的操作。

![](../imgs/c3/geohash.png)

曼哈顿距离由纽约市曼哈顿的棋盘式街道布局而得名，定义为两个点的坐标轴投影长度之。在二维平面上，两点 (x1, y1) 和 (x2, y2) 之间的曼哈顿距离为：

$$d(x, y) = |x_1 - y_1| + |x_2 - y_2|$$

考虑到轨迹点密度较高，相邻点之间的距离很短，且经纬度变化范围较小（绝大部分相邻点之间的经纬度跨度不超过0.001°），因此曼哈顿距离能够有效捕捉轨迹点的局部运动特征。且曼哈顿距离的计算公式简单，仅涉及绝对值运算，计算效率高。对于具有大量轨迹点的GPS数据，使用曼哈顿距离可以显著降低计算成本。因此，本算法通过计算两个坐标点之间的曼哈顿距离来判断两个点之间实际的空间距离。

| 经度 | 纬度 |
| -- | -- |
|121.347|31.392|
|121.348|31.389|
|121.349|31.390|
|121.350|31.390|
| ... | ... |

对于乱序轨迹点集，在知道始末点的前提下，本文提出了一种基于 GeoHash 空间索引及曼哈顿距离及贪婪策略轨迹重排序算法:认为所有记录中的轨迹点集都是乱序状态，对于任意一轨迹点集，首先创建空列表 List 并将包含了起点和终点的所有点组成的列表 Pn 逐点计算 GeoHash 编码并放入集合 GeoHash 中（该步骤同时借助集合的特性实现了去重复）。然后，循环迭代，直到轨迹点列表为空。在每次迭代中，算法会计算当前点与轨迹末尾点的曼哈顿距离，并找到距离最近的点。如果找到的最近点就是终点，则算法终止，否则将最近点加入轨迹并从 GeoHash 集合中删除。最后，将轨迹列表 List 中的 GeoHash 编码转换为坐标并返回简化后的轨迹。

![](../imgs/3.3-2.png)

由于 Python 编程语言的集合（Set）原生的散列值计算函数作用于元组（tuple）类型的数据时会发生二进制精度损失，所以需要首先使用 GeoHash 算法对位置元组进行编码（encode）再将得到的字符串存入集合中，在需要用到实际坐标时再使用对应的解码方法（decode），这样可以规避使用存入及去除集合时由于散列值计算带来的精度损失。考虑到 GeoHash 编码存在距离失真的问题，本算法使用两经纬度坐标间的曼哈顿距离来估算实际距离。以下是对某一真实路径进行排序的实际效果：

![](../imgs/c3/轨迹排序.png)

假设地球是一个球体，球面半径为 r（取 6371000 米），用经度 lon 和纬度 lat 表示球面上的点，则在已知有序骑行轨迹 n 个点组成的列表($List = [(lon1, lat1), (lon2, lat2), \cdots, (lonn, latn)]$)的情况下，可以使用 Haversine 算法计算得每字轨迹的长度再累加得总轨迹长度。

$$d = \sum_{i=1}^{n-1} 2r \arcsin(\sqrt{\sin^2(\frac{lat_{i+1} - lat_i}{2}) + \cos(lat_i) \cos(lat_{i+1}) \sin^2(\frac{lon_{i+1} - lon_i}{2})})$$

使用上述方法对一段轨迹进行处理，计算得轨迹起点与终点间的直接半正弦距离为 2118.25 米，未排序轨迹点集的累计半正弦距离（认为地球半径为 6371000 米）为 8685.89 米，经过算法重排序后的累计半正弦距离为 3605.04 米。可以发现，由于未经处理的轨迹点集中存在部分不合理的乱序点，导致轨迹总长度明显偏大，经算法重排序后的轨迹点集较为合理。在中央处理器为 i7-10870H，机带RAM 16GB 的 Windows11 笔记本上，使用该算法处理十万条轨迹数据总耗时约1小时31分。

### 3.2.3 轨迹简化
共享单车位置记录设备通常以固定频率记录并上传数据，导致即使经过轨迹重排序，仍存在大量冗余点。例如，平直路段可能出现过于密集的轨迹点，增加后续分析负担。此外，由于定位精度限制，用户沿着某些路径运动时，轨迹会呈现锯齿状噪声，这也会影响后续分析。

为了解决上述问题，本文提出了一种基于曼哈顿距离的道格拉斯-普克算法来简化共享单车轨迹。该算法可以有效地去除冗余点和锯齿状噪声，使轨迹更加简洁明了，从而为后续分析提供更好的基础。道格拉斯-普克算法是一种基于点的轨迹简化算法，而为了平滑锯齿状轨迹噪声，该算法采用累计曼哈顿距离作为分割点的选择标准。具体而言，算法首先考察当前点与线段起点及终点的曼哈顿距离，若大于阈值则保留该点为特征点，并剖分线段递归调用直到无法剖分。这种方式能够在保留轨迹基本形状的情况下，有效地平滑带有锯齿状噪声的轨迹线。

基于欧氏距离的道格拉斯-扑克法需要计算带有开方操作的欧氏距离，同时需要求解直线表达式再计算点到线的垂距，相比之下本算法采用曼哈顿距离具有一定的性能优势。

![](../imgs/c3/轨迹化简.png)

可以发现，当阈值取0.015度时，即可有效去除由于低定位精度带来的锯齿状噪声，同时保留轨迹的总体形状。可以通过调小阈值来保留一定的细节，实验表明，基于曼哈顿距离的道格拉斯-普克算法可以有效地去除共享单车轨迹中的冗余点和锯齿状噪声，在保持轨迹基本形状的同时，显著减少了轨迹点的数量。这对于后续的轨迹分析，例如轨迹聚类、异常检测等，具有重要的意义。

## 3.3 研究方法

### 3.3.1 轨迹终点最近邻匹配算法

骑行轨迹数据缺乏对骑行目的的直接标注，限制了对其深入分析。本文提出一种基于兴趣点数据的骑行终点分析方法，通过将骑行终点匹配到最近的兴趣点类别，推断骑行者的行为目的。该方法可有效识别购物、通勤、休闲等行为模式，为共享单车服务优化提供依据。

对于某一段轨迹的终点，可以提取距离其最近兴趣点的类别，这种查找最邻近点并赋值的思想是本算法的指导思想。但是，本文使用到的上海市兴趣点数据集有十二万多条数据，轨迹数据在清洗后也有近十万条。如果直接对所有点进行暴力搜素，算法时间复杂度约为 $O(n^2)$，粗略估计将执行120亿次半正弦距离计算（haversine）。据本机（i7-10870H,RAM 16 GB）测算，执行一次 haversine 算法大约消耗 15 μs，粗略估计，在不考虑排序操作的情况下，算法将执行超过三小时，因此需要建立用于支持高效查找的空间数据结构。考虑到 GeoHash 编码的层次结构，本文构建了 GeoHash 树索引，支持高效的兴趣点查找。GeoHash 树是一种基于前缀树的树形索引结构，能够快速筛选出与目标编码字符串相似度较高的兴趣点，本文针对 GeoHash 编码字符串实现了这种树形索引，该索引支持插入（insert）及查询（query）特定的编码字符串。

该算法首先对兴趣点数据集构建树形索引（GeoHashTree），而后对某一个轨迹终点执行逐步扩大搜索空间范围的贪心算法（greedyQuery）。贪心搜索算法对输入编码字符串首先执行一次搜索操作，若未得到返回值，就会逐个去除最后一位（扩大空间范围）并再次搜索，直到找到最邻近的兴趣点（或者待匹配编码为空）。该算法的流程如下：

![](../imgs/c3/最邻近匹配.png)

高效的空间索引大大加快了最邻近查找的速度，经试验，在十二万条兴趣点数据集中使用该算法对近十万条轨迹数据的终点进行最邻近匹配共耗费约两分钟。

### 3.3.2 改进的 TRACLUS 算法（基于 OPTICS 聚类算法）

### 参考内容

相较于K均值聚类，基于密度的聚类支持任意形状

- Our key observation is that clustering trajectories as a whole could not detect similar portions of the trajectories. We note that a trajectory may have a long and complicated path. Hence, even though some portions of trajectories show a common behavior, the whole trajectories might not.
- 基于密度聚类的好处：Density-based clustering methods are the most suitable for line segments because they can discover clusters of arbitrary shape and can filter out noises.

## 3.4 本章小结

## references
[15]郭雨,陈金勇,张新宇,等.OPTICS与离线批处理在轨迹聚类中的应用[J].计算机工程,2020,46(7):72-77,83.
